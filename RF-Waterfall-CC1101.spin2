{
    --------------------------------------------
    Filename: RF-Waterfall-CC1101.spin2
    Description: Display received power levels in the frequency domain
        as a "waterfall"
        Utilizes ISM-band transceiver IC's (CC1101 version)
    Author: Jesse Burt
    Copyright (c) 2020
    Started: Apr 6, 2020
    Updated: Apr 28, 2020
    See end of file for terms of use.
    --------------------------------------------
}
CON

    _clkfreq        = 250_000_000
    _xtlfreq        = cfg._xtlfreq

' -- User-modifiable constants
    SER_BAUD        = 2_000_000
    LED             = cfg.LED1

' CC1101
    BASEPIN         = 0
    CS_PIN          = BASEPIN+3'8
    SCK_PIN         = BASEPIN+2'9
    MOSI_PIN        = BASEPIN+0'10                             ' This pin relationship is mandatory
    MISO_PIN        = BASEPIN+1'11                             '
    SCK_FREQ        = 10_000_000

    VGA_BASEPIN     = 32                                     ' 0, 8, 16, 24, 32, 40, 48
'                                                           Works with all basepins on the P2ES except 56
' --

    WIDTH           = 320
    HEIGHT          = 240
    XMAX            = WIDTH-1
    YMAX            = HEIGHT-1
    BUFFSZ          = WIDTH * HEIGHT
    BPP             = vga.BYTESPERPX
    BPL             = (WIDTH * HEIGHT) * BPP

    LABEL_COL       = 0
    DATA_COL        = 11
' User-modifiable constants

VAR

    long _palette[256]
    long _strtemp[4]
    long _center, _basefreq, _span, _start, _end
    long _dly

    word _wf_x, _wf_y, _wf_width, _wf_height
    byte _framebuffer[BUFFSZ]

    byte _offset

OBJ

    cfg         : "core.con.boardcfg.p2eval"
    ser         : "com.serial.terminal.ansi"
    time        : "time"
    io          : "io"
    vga         : "display.vga.bitmap-8bpp"
'    vga         : "vga1"
    int         : "string.integer"
    fnt         : "font.5x8"
    cc1101      : "wireless.transceiver.cc1101.spi"

PUB Main() | lna, dvga, cmd, rxbw, intfreq

    fullspecpalette()
'    greyscalepalette()
    setup()
    _center := 433_800_000                                    ' 300_000_000..348_000_000, 387_000_000..464_000_000, 779_000_000..928_000_000
    _span := 250_000                                          ' Freq span from base freq
    _start := _center - (_span/2)
    _end := _center + (_span/2)

    cc1101.gpio0(cc1101.IO_HI_Z)
    cc1101.idle()                                               ' Change to Idle while changing settings
    cc1101.autocal(cc1101.IDLE_RXTX)
    cc1101.carrierfreq(_basefreq)
    cc1101.syncmode(cc1101.SYNCMODE_3032_CS)
    cc1101.carriersense(14)
    cc1101.magntarget(24)
    cc1101.dvgagain(-3)
    cc1101.lnagain(0)
    cc1101.rxbandwidth(58)
    cc1101.agcmode(cc1101.AGC_OFF)
    cc1101.dcblock(FALSE)
    cc1101.rxmode()

    lna := dvga := rxbw := 0
    intfreq := 380859
    _offset := 138 #> 138

' Waterfall position, width, height
    _wf_x := 0
    _wf_y := vga.fontheight() * 6
    _wf_width := _wf_x+300
    _wf_height := _wf_y+(vga.fontheight() * 12)-4

    vga.box(_wf_x, _wf_y, _wf_width, _wf_height, 255, FALSE)                       ' Draw frame around waterfall
    displaysettings()

    drawscale(_wf_width+5, _wf_y, _wf_height-_wf_y)                                      ' Draw the color scale (for RSSI)
    repeat
        waterfall(_wf_x, _wf_y, _wf_width, _wf_height, _basefreq, _span)
        if lookdown(cmd := ser.rxcheck(): 32..127)
            case cmd
                "=":
                    lna := (lna + 1) <# 7
                    cc1101.lnagain(lookupz(lna: -17, -14, -11, -9, -7, -6, -2, 0))
                "-":
                    lna := (lna - 1) #> 0
                    cc1101.lnagain(lookupz(lna: -17, -14, -11, -9, -7, -6, -2, 0))
                "]":
                    dvga := (dvga + 1) <# 7
                    cc1101.dvgagain(lookupz(dvga: -3, -2, -1, 0))
                "[":
                    dvga := (dvga - 1) #> 0
                    cc1101.dvgagain(lookupz(dvga: -3, -2, -1, 0))
                ";":
                    _offset := (_offset - 1) #> 138
                "'":
                    _offset := (_offset + 1) <# 255
                ".":
                    rxbw := (rxbw + 1) <# 15
                    cc1101.rxbandwidth(lookupz(rxbw: 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650, 812))
                ",":
                    rxbw := (rxbw - 1) #> 0
                    cc1101.rxbandwidth(lookupz(rxbw: 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650, 812))
                "p":
                    intfreq := (intfreq + 25390) <# 787109
                    cc1101.intfreq(intfreq)
                "o":
                    intfreq := (intfreq - 25390) #> 25390
                    cc1101.intfreq(intfreq)
                "s":
                    _span := (_span - 10_000) #> 10_000
                "S":
                    _span := (_span + 10_000) <# 5_000_000
                "b":
                    _basefreq := (_basefreq - 50_000) #> 300_000_000
                "B":
                    _basefreq := (_basefreq + 50_000) <# 928_000_000
                "d":
                    _dly := (_dly-1) #> 0
                    ser.printf("%d\n", _dly)

                "D":
                    _dly := (_dly+1) <# 1000
                    ser.printf("%d\n", _dly)

                other:
            cc1101.rxmode()
            displaysettings()                                   ' Update the settings display

PUB DisplaySettings() | basefreq, span, lna, dvga, rxbw, ifreq, startrow

    lna := cc1101.lnagain()
    dvga := cc1101.dvgagain()
    rxbw := cc1101.rxbandwidth()
    ifreq := cc1101.intfreq()

    vga.fgcolor(255)
    vga.position(0, 2)

    decthousands(_basefreq, ",") ' XXX should be able to use the return value from this, but it doesn't work with the vga object
    vga.printf("%sHz", @_strtemp)
    decthousands(_span, ",")
    vga.printf("   Span: %sHz   ", @_strtemp)

    startrow := ((_wf_y + _wf_height+4) / vga.fontheight())

    vga.position(LABEL_COL, startrow)
    vga.printf("LNA Gain: ")
    vga.position(DATA_COL, startrow)
    vga.printf("%ddB ", lna)

    vga.position(LABEL_COL, startrow+1)
    vga.printf("DVGA Gain: ")
    vga.position(DATA_COL, startrow+1)
    vga.printf("%ddB ", dvga)

    vga.position(LABEL_COL, startrow+2)
    vga.printf("RX BW: ")
    vga.position(DATA_COL, startrow+2)
    vga.printf("%dkHz  ", rxbw)

    vga.position(LABEL_COL, startrow+3)
    vga.printf("IF: ")
    vga.position(DATA_COL, startrow+3)
    ifnot ifreq/1000 > (rxbw/2)
        vga.fgcolor(190)
    else
        vga.fgcolor(255)
    vga.printf("%dHz ", ifreq)
    vga.fgcolor(255)

PUB Waterfall(sx, sy, ex, ey, base_freq, span) | x, y, left, top, bottom, right, c, freqstep

    left := sx + 1
    top := sy + 1
    bottom := ey - 1
    right := ex - 1
    freqstep := (span/(ex-sx))                                  ' *CC1101 Freq resolution is actually 397Hz

    repeat x from left to right
        cc1101.carrierfreq(base_freq + (freqstep * (x-left)))
        c := (cc1101.rssi()+_offset)
        vga.plot(x, top, c)
{
        y := sy-(c/3)+5                                         ' Plot above waterfall
        vga.plot(x, y-1 <# (sy-2), 127)                         '
        vga.plot(x, y-2 <# (sy-2), 0)                           '
        vga.line(x, sy-1, x, y <# (sy-2), 0)                    '
}
'    vga.waitvsync()
'    repeat 2
    vga.scrolldown(left, top, right, bottom)

PRI DrawScale(x, y, ht) | idx, color, scl_width, bottom, top, range
' Draw the color scale setup at program start
    range := bottom := y+ht
    top := y
    scl_width := 5

    repeat idx from bottom to top
        color := (range-idx)                                ' Skip every other color in the scale
        vga.Line(x, idx, x+scl_width, idx, color)               '   so most of it can be fit on screen

PRI DecThousands(n, sep_char): ptr_str | instr[4], inlen, idx, outstr[4], outlen, outidx, sepidx
' Display a decimal number (unsigned int) with thousands separators
'   n:          0..2147483647
'   sep_char:   32..127 (ASCII character)
    case n                                                  ' Validate number
        0..POSX:
        other:
            return string("ERR")                            ' Return "ERR" if out of range

    case sep_char                                           ' Validate separator character
        32..127:
        other:
            return string("ERR")

    instr := 0
    outstr := 0
    inlen := idx := outlen := outidx := sepidx := 0
    instr := int.dec(n)                                     ' Convert num to string
    inlen := strsize(instr)
    outlen := inlen + ( (inlen-1) / 3 )                     ' Output string length is input length plus enough space for separator characters

    idx := inlen-1                                          ' Start at the end of the string
    outidx := outlen-1                                      '   (= least significant digit)

    repeat while outidx => 0
        case sepidx                                         ' Use separator index to determine what gets copied to the output next
            0..2:                                           ' Index 0, 1, or 2 is a digit
                outstr.byte[outidx] := byte[instr][idx]
                idx--
                sepidx++
            3:                                              ' 3 means we're at the next thousands place - output a separator character
                outstr.byte[outidx] := sep_char
                sepidx := 0
        outidx--                                            ' Traverse one character
    outstr.byte[outlen] := 0                                ' When finished, terminate the array with a NUL(0) character, to make it a string
    longmove(@_strtemp, @outstr, 4)
    return @outstr

PUB Setup()

    ser.start(SER_BAUD)
    ser.clear()
    ser.printf("Serial terminal started - p2 @ %dMHz\n", clkfreq/1000000)

'    vga.settimings(10, 33, 16, 96, 48, 640) ' capture
    vga.settimings(10, 33, 16, 89, 85, 640)
    if vga.start(VGA_BASEPIN, @_framebuffer, @_palette, WIDTH, HEIGHT)
'        ser.strln(string("VGA 8bpp driver started"))
        vga.fontspacing(1, 1)
        vga.fontscale(1)
        vga.fontsize(fnt.WIDTH, fnt.HEIGHT)
        vga.fontaddress(fnt.baseaddr())
        vga.clear()
        ser.strln(string("VGA 8bpp driver started"))
    else
        ser.strln(string("VGA 8bpp driver failed to start"))
        repeat

    if cc1101.startx(CS_PIN, SCK_PIN, MOSI_PIN, MISO_PIN, SCK_FREQ)
        ser.strln(string("CC1101 driver started"))
    else
        ser.strln(string("CC1101 driver failed to start - halting"))
        repeat

PUB GreyScalePalette() | i

    repeat i from 0 to 255
        _palette[i] := 0 | (i << 16) | (i << 8) | i

PUB FullSpecPalette() | i, r, g, b, c
' Set up palette
    r := g := b := c := 0
    repeat i from 0 to 255
        case i
            0..31:
                r += 4
                g := 0
                b += 4
            32..63:
                r -= 4
                g := 0
                b := b
            64..95:
                r := 0
                g += 4
                b := b
            96..127:
                r := 0
                g := g
                b -= 4
            128..159:
                r += 4
                g := g
                b := b
            160..191:
                r := r
                g -= 4
                b := 0
            192..254:
                r := r
                g += 4
                b += 4
            255:
                r := g := b := 255

        c := 0 | (r << 16) | (g << 8) | b
        _palette[i] := c
    _palette[0] := $00_00_00_00

{
    --------------------------------------------------------------------------------------------------------
    TERMS OF USE: MIT License

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
    associated documentation files (the "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
    following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --------------------------------------------------------------------------------------------------------
}

