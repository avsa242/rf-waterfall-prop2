{
    --------------------------------------------
    Filename: RF-Waterfall-CC2500.spin2
    Description: Display received power levels in the frequency domain
        as a "waterfall"
        Utilizes ISM-band transceiver IC's (CC2500 version)
    Author: Jesse Burt
    Copyright (c) 2023
    Started: Apr 28, 2020
    Updated: Jul 17, 2023
    See end of file for terms of use.
    --------------------------------------------
}
CON

    _clkfreq    = 250_000_000
    _xtlfreq    = 20_000_000

    WIDTH           = 320
    HEIGHT          = 240
    XMAX            = WIDTH-1
    YMAX            = HEIGHT-1
    BUFFSZ          = WIDTH * HEIGHT

    LABEL_COL       = 0
    DATA_COL        = 11

    SER_BAUD        = 2_000_000

    VGA_BASEPIN     = 32                                     ' 0, 8, 16, 24, 32, 40, 48
'                                                           Works with all basepins on the P2ES except 56

VAR

    long _strtemp[4]
    long _basefreq, _span
    long _dly

    word _wf_x, _wf_y, _wf_width, _wf_height
    byte _framebuffer[BUFFSZ]

    byte _offset

OBJ

    cfg:    "boardcfg.p2eval"
    ser:    "com.serial.terminal.ansi"
    vga:    "display.vga.bitmap-8bpp"
    fnt:    "font.5x8"
    cc2500: "wireless.transceiver.cc2500" | CS=0, SCK=1, MOSI=2, MISO=3, SPI_FREQ=6_500_000
    str:    "string"

PUB Main | lna, dvga, cmd, rxbw, intfreq

    vga.set_timings(10, 33, 16, 89, 85, 640)
    full_spec_palette()
'    grey_scale_palette
    setup

    _basefreq := 2_400_000                                      ' 2_400_000..2_483_500 (kHz)
    _span := 1_000_000                                          ' Freq span from base freq

    cc2500.Idle                                                 ' Change to Idle while changing settings
    cc2500.Auto_Cal_mode(cc2500#IDLE_RXTX)
    cc2500.Carrier_Freq(_basefreq)
    cc2500.Syncwd_Mode(cc2500#SYNCMODE_3032_CS)
    cc2500.Carrier_Sense_thresh(14)
    cc2500.dvga_gain(-3)
    cc2500.lna_gain(-17)
    cc2500.RX_Bw(58)
    cc2500.Interm_Freq(380859)
    cc2500.AGC_Mode(cc2500#AGC_OFF)                              ' AGC_NORMAL, AGC_OFF
    cc2500.DC_Block_ena(FALSE)
    cc2500.RX_Mode()

    lna := dvga := rxbw := 0
    intfreq := 380859
    _offset := 138 #> 138

' Waterfall position, width, height
    _wf_x := 0
    _wf_y := vga.FontHeight * 6
    _wf_width := _wf_x+300
    _wf_height := _wf_y+(vga.FontHeight * 12)-4

    vga.Box(_wf_x, _wf_y, _wf_width, _wf_height, 255, FALSE)                       ' Draw frame around waterfall
    DisplaySettings

    DrawScale(_wf_width+5, _wf_y, _wf_height-_wf_y)                                      ' Draw the color scale (for RSSI)

    repeat
        Waterfall(_wf_x, _wf_y, _wf_width, _wf_height, _basefreq, _span)
        if lookdown(cmd := ser.rxcheck: 32..127)
            cc2500.Idle
            case cmd
                "=":
                    lna := (lna + 1) <# 7
                    cc2500.lna_gain(lookupz(lna: -17, -14, -11, -9, -7, -6, -2, 0))
                "-":
                    lna := (lna - 1) #> 0
                    cc2500.lna_gain(lookupz(lna: -17, -14, -11, -9, -7, -6, -2, 0))
                "]":
                    dvga := (dvga + 1) <# 7
                    cc2500.dvga_gain(lookupz(dvga: -3, -2, -1, 0))
                "[":
                    dvga := (dvga - 1) #> 0
                    cc2500.dvga_gain(lookupz(dvga: -3, -2, -1, 0))
                ";":
                    _offset := (_offset - 1) #> 138
                "'":
                    _offset := (_offset + 1) <# 255
                ".":
                    rxbw := (rxbw + 1) <# 15
                    cc2500.rx_bw(lookupz(rxbw: 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650, 812))
                ",":
                    rxbw := (rxbw - 1) #> 0
                    cc2500.rx_bw(lookupz(rxbw: 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650, 812))
                "p":
                    intfreq := (intfreq + 25390) <# 787109
                    cc2500.interm_freq(intfreq)
                "o":
                    intfreq := (intfreq - 25390) #> 25390
                    cc2500.interm_freq(intfreq)
                "s":
                    _span := (_span - 10_000) #> 10_000
                "S":
                    _span := (_span + 10_000) <# 5_000_000
                "b":
                    _basefreq := (_basefreq - 500) #> 2_400_000
                "B":
                    _basefreq := (_basefreq + 500) <# 2_483_500
                "d":
                    _dly := (_dly-1) #> 0
                    ser.printf("%d\n", _dly)

                "D":
                    _dly := (_dly+1) <# 1000
                    ser.printf("%d\n", _dly)

                OTHER:
            cc2500.rx_mode()
            DisplaySettings                                     ' Update the settings display

PUB DisplaySettings | basefreq, span, lna, dvga, rxbw, ifreq, startrow

    lna := cc2500.lna_gain()
    dvga := cc2500.dvga_gain()
    rxbw := cc2500.rx_bw()
    ifreq := cc2500.interm_freq()

    vga.FGColor(255)
    vga.position(0, 0)

    DecThousands(_basefreq, ",") ' XXX should be able to use the return value from this, but it doesn't work with the vga object
    vga.printf("%skHz", @_strtemp)
    DecThousands(_span, ",")
    vga.printf("   Span: %sHz   ", @_strtemp)

    startrow := ((_wf_y + _wf_height+4) / vga.FontHeight)

    vga.position(LABEL_COL, startrow)
    vga.printf("LNA Gain: ")
    vga.position(DATA_COL, startrow)
    vga.printf("%ddB ", lna)

    vga.position(LABEL_COL, startrow+1)
    vga.printf("DVGA Gain: ")
    vga.position(DATA_COL, startrow+1)
    vga.printf("%ddB ", dvga)

    vga.position(LABEL_COL, startrow+2)
    vga.printf("RX BW: ")
    vga.position(DATA_COL, startrow+2)
    vga.printf("%dkHz  ", rxbw)

    vga.position(LABEL_COL, startrow+3)
    vga.printf("IF: ")
    vga.position(DATA_COL, startrow+3)
    ifnot ifreq/1000 > (rxbw/2)
        vga.fgcolor(190)
    else
        vga.fgcolor(255)
    vga.printf("%dHz ", ifreq)
    vga.fgcolor(255)

PUB Waterfall(sx, sy, ex, ey, base_freq, span) | x, y, left, top, bottom, right, c, freqstep

    left := sx + 1
    top := sy + 1
    bottom := ey - 1
    right := ex - 1
    freqstep := span / (ex-sx)                                  ' *CC2500 Freq resolution is actually 397Hz
' span = 1_000_000
' sx = 0
' ex = 300
' --------
' freqstep = 3333 (/ 1000 = 3.333)
' left = 1
' base_freq = 2_400_000
' (2_400_000 + (3 * (0-1)))
    vga.wait_vsync()
    repeat x from left to right
        cc2500.carrier_freq(base_freq + (freqstep * (x-left)) / 1000)
'        time.USleep(_dly)
        c := (cc2500.RSSI+_offset)
        vga.Plot(x, top, c)
{
        y := sy-(c/3)+5                                         ' Plot above waterfall
        vga.Plot(x, y-1 <# (sy-2), 127)                         '
        vga.Plot(x, y-2 <# (sy-2), 0)                           '
        vga.Line(x, sy-1, x, y <# (sy-2), 0)                    '
}
    vga.ScrollDown(left, top, right, bottom)

PRI DrawScale(x, y, ht) | idx, color, scl_width, bottom, top, range
' Draw the color scale setup at program start
    range := bottom := y+ht
    top := y
    scl_width := 5

    repeat idx from bottom to top
        color := (range-idx) * 2                                ' Skip every other color in the scale
        vga.Line(x, idx, x+scl_width, idx, color)               '   so most of it can be fit on screen

PRI DecThousands(n, sep_char) | instr[4], inlen, idx, outstr[4], outlen, outidx, sepidx
' Display a decimal number (unsigned int) with thousands separators
'   n:          0..2147483647
'   sep_char:   32..127 (ASCII character)
    case n                                                  ' Validate number
        0..POSX:
        OTHER:
            return string("ERR")                            ' Return "ERR" if out of range

    case sep_char                                           ' Validate separator character
        32..127:
        OTHER:
            return string("ERR")

    instr := 0
    outstr := 0
    inlen := idx := outlen := outidx := sepidx := 0
    instr := str.dec(n)                                     ' Convert num to string
    inlen := strsize(instr)
    outlen := inlen + ( (inlen-1) / 3 )                     ' Output string length is input length plus enough space for separator characters

    idx := inlen-1                                          ' Start at the end of the string
    outidx := outlen-1                                      '   (= least significant digit)

    repeat while outidx => 0
        case sepidx                                         ' Use separator index to determine what gets copied to the output next
            0..2:                                           ' Index 0, 1, or 2 is a digit
                outstr.byte[outidx] := byte[instr][idx]
                idx--
                sepidx++
            3:                                              ' 3 means we're at the next thousands place - output a separator character
                outstr.byte[outidx] := sep_char
                sepidx := 0
        outidx--                                            ' Traverse one character
    outstr.byte[outlen] := 0                                ' When finished, terminate the array with a NUL(0) character, to make it a string
    longmove(@_strtemp, @outstr, 4)
    return @outstr

PUB Setup

    ser.Start(SER_BAUD)
    ser.clear
    ser.strln(@"Serial terminal started")

    if vga.start(VGA_BASEPIN, WIDTH, HEIGHT, @_framebuffer)
        vga.font_addr(fnt.ptr())
        vga.font_scl(1)
        vga.font_spacing(1, 0)
        vga.font_sz(fnt.WIDTH, fnt.HEIGHT)
        vga.clear()
        ser.strln(@"VGA 8bpp driver started")
        vga.char_attrs(vga.DRAWBG)
    else
        ser.strln(@"VGA 8bpp driver failed to start")
        repeat

    if cc2500.Start()
        ser.strln(@"CC2500 driver started")
    else
        ser.strln(@"CC2500 driver failed to start - halting")
        repeat

PUB grey_scale_palette() | i, ptr_pal

    repeat i from 0 to 255
        long[ptr_pal][i] := 0 | (i << 16) | (i << 8) | i

PUB full_spec_palette() | i, r, g, b, c, ptr_pal
' Set up palette
    r := g := b := c := 0
    ptr_pal := vga.palette_ptr()
    repeat i from 0 to 255
        c := 0 | (r << 16) | (g << 8) | b
        long[ptr_pal][i] := c
        case i
            0..31:
                r += 4
                g := 0
                b += 4
            32..63:
                r -= 4
                g := 0
                b := b
            64..95:
                r := 0
                g += 4
                b := b
            96..127:
                r := 0
                g := g
                b -= 4
            128..159:
                r += 4
                g := g
                b := b
            160..191:
                r := r
                g -= 4
                b := 0
            192..253:
                r := r
                g += 4
                b += 4
            254..255:
                r := g := b := 255

DAT
{
Copyright 2023 Jesse Burt

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}

