{
    --------------------------------------------
    Filename: RF-Waterfall-SX1231.spin2
    Description: Display received power levels in the frequency domain
        as a "waterfall"
        Utilizes ISM-band transceiver IC's, e.g., the CC1101, SX1231
    Author: Jesse Burt
    Copyright (c) 2020
    Started: Apr 6, 2020
    Updated: Apr 14, 2020
    See end of file for terms of use.
    --------------------------------------------
}
CON

    ' 250MHz
    _clkfreq        = 250_000_000
    _xtlfreq       = cfg#_xtlfreq

' -- User-modifiable constants
    SER_BAUD        = 2_000_000
    LED             = cfg#LED1

    CS_PIN          = 0
    SCK_PIN         = 1
    MOSI_PIN        = 2
    MISO_PIN        = 3
    SCK_FREQ        = 10_000_000

    VGA_BASEPIN     = 32                         ' 0, 8, 16, 24, 32, 40, 48
' --

    WIDTH           = 320
    HEIGHT          = 240
    XMAX            = WIDTH-1
    YMAX            = HEIGHT-1
    BUFFSZ          = WIDTH * HEIGHT
    BPP             = 1
    BPL             = WIDTH * BPP

    LABEL_COL       = 0
    DATA_COL        = 11

VAR

    long _palette[255]
    long _strtemp[4]
    long _basefreq, _span
    long _dly

    word _wf_x, _wf_y, _wf_width, _wf_height
    byte _framebuffer[BUFFSZ]

    byte _offset

OBJ

    cfg         : "core.con.boardcfg.p2eval"
    ser         : "com.serial.terminal.ansi"
    vga         : "display.vga.bitmap-8bpp"
    int         : "string.integer"
    fnt         : "font.5x8"
    sx1231      : "wireless.transceiver.sx1231.spi"

PUB Main() | lna, cmd, rxbw

    fullspecpalette()
'    greyscalepalette()
    setup()

    _basefreq := 902_300_000                    ' 290_000_000..340_000_000, 424_000_000..510_000_000, 862_000_000..1_020_000_000
    _span := 500_000                            ' Freq span from base freq

    sx1231.idle()
    sx1231.rcosccal(TRUE)
    sx1231.carrierfreq(_basefreq)
    sx1231.lnazinput(50)
    sx1231.lnagain(-48)
    sx1231.rxbandwidth(2_600)
    sx1231.rxmode()

    lna := rxbw := 0
    _offset := 115 #> 115

' Waterfall position, width, height
    _wf_x := 0
    _wf_y := vga.fontheight() * 6
    _wf_width := _wf_x+300
    _wf_height := _wf_y+(vga.fontheight() * 12)-4

    vga.box(_wf_x, _wf_y, _wf_width, _wf_height, 255, FALSE)' Draw frame around waterfall
    displaysettings()

    drawscale(_wf_width+5, _wf_y, _wf_height-_wf_y)         ' Draw the color scale (for RSSI)

    repeat
        Waterfall(_wf_x, _wf_y, _wf_width, _wf_height, _basefreq, _span)
        if lookdown(cmd := ser.rxcheck(): 32..127)
            case cmd
                "=":
                    lna := (lna + 1) <# 7
                    sx1231.lnagain(lookupz(lna: -48, -36, -24, -12, -6))
                "-":
                    lna := (lna - 1) #> 0
                    sx1231.lnagain(lookupz(lna: -48, -36, -24, -12, -6))
                ";":
                    _offset := (_offset - 1) #> 115
                "'":
                    _offset := (_offset + 1) <# 255
                ".":
                    rxbw := (rxbw + 1) <# 23
                    sx1231.rxbandwidth(lookupz(rxbw: 500000, 400000, 333300, 250000, 200000, 166700, 125000, 100000, 83300, 62500, 50000, 41700, 31300, 25000, 20800, 15600, 12500, 10400, 7800, 6300, 5200, 3900, 3100, 2600))
                    ser.printf("rxbw: %d    rxbandwidth: %d\n", rxbw, sx1231.rxbandwidth())
                ",":
                    rxbw := (rxbw - 1) #> 0
                    sx1231.rxbandwidth(lookupz(rxbw: 500000, 400000, 333300, 250000, 200000, 166700, 125000, 100000, 83300, 62500, 50000, 41700, 31300, 25000, 20800, 15600, 12500, 10400, 7800, 6300, 5200, 3900, 3100, 2600))
                    ser.printf("rxbw: %d    rxbandwidth: %d\n", rxbw, sx1231.rxbandwidth())
                "s":
                    _span -= 1000
                "S":
                    _span += 1000
                "b":
                    _basefreq -= 50_000
                "B":
                    _basefreq += 50_000
                "d":
                    _dly := (_dly-1) #> 0
                    ser.printf("%d\n", _dly)

                "D":
                    _dly := (_dly+1) <# 1000
                    ser.printf("%d\n", _dly)

                OTHER:
            DisplaySettings()                   ' Update the settings display

PUB DisplaySettings() | basefreq, span, lna, dvga, rxbw, ifreq, startrow

    lna := sx1231.lnagain()
    dvga := sx1231.dvgagain()
    rxbw := sx1231.rxbandwidth()
    ifreq := sx1231.intfreq()

    vga.fgcolor(255)
    vga.position(0, 0)

    decthousands(_basefreq, ",") ' XXX should be able to use the return value from this, but it doesn't work with the vga object
    vga.printf("%sHz", @_strtemp)
    decthousands(_span, ",")
    vga.printf("   Span: %sHz   ", @_strtemp)

    startrow := ((_wf_y + _wf_height+4) / vga.fontheight())

    vga.position(LABEL_COL, startrow)
    vga.printf("LNA Gain: ")
    vga.position(DATA_COL, startrow)
    vga.printf("%ddB ", lna)

    vga.position(LABEL_COL, startrow+2)
    vga.printf("RX BW: ")
    vga.position(DATA_COL, startrow+2)
    vga.printf("%dkHz  ", rxbw)

PUB Waterfall(sx, sy, ex, ey, base_freq, span) | x, y, left, top, bottom, right, c, freqstep

    left := sx + 1
    top := sy + 1
    bottom := ey - 1
    right := ex - 1
    freqstep := (span/(ex-sx))
   
    vga.waitvsync()
    repeat x from left to right
        sx1231.carrierfreq(base_freq + (freqstep * (x-left)))
'        waitus(_dly)
        c := (sx1231.rssi()+_offset)
        vga.plot(x, top, c)

        y := sy-(c/3)+5                                         ' plot above waterfall
        vga.plot(x, y-1 <# (sy-2), 127)                         '
        vga.plot(x, y-2 <# (sy-2), 0)                           '
        vga.line(x, sy-1, x, y <# (sy-2), 0)                    '

    vga.scrolldown(left, top, right, bottom)

PRI DrawScale(x, y, ht) | idx, color, scl_width, bottom, top, range
' Draw the color scale setup at program start
    range := bottom := y+ht
    top := y
    scl_width := 5

    repeat idx from bottom to top
        color := (range-idx) * 2                            ' Skip every other color in the scale
        vga.line(x, idx, x+scl_width, idx, color)           '   so most of it can be fit on screen

PRI DecThousands(n, sep_char): retstr | instr[4], inlen, idx, outstr[4], outlen, outidx, sepidx
' Display a decimal number (unsigned int) with thousands separators
'   n:          0..2147483647
'   sep_char:   32..127 (ASCII character)
    case n                                                  ' Validate number
        0..POSX:
        OTHER:
            return string("ERR")                            ' Return "ERR" if out of range

    case sep_char                                           ' Validate separator character
        32..127:
        OTHER:
            return string("ERR")

    instr := 0
    outstr := 0
    inlen := idx := outlen := outidx := sepidx := 0
    instr := int.dec(n)                                     ' Convert num to string
    inlen := strsize(instr)
    outlen := inlen + ( (inlen-1) / 3 )                     ' Output string length is input length plus enough space for separator characters

    idx := inlen-1                                          ' Start at the end of the string
    outidx := outlen-1                                      '   (= least significant digit)

    repeat while outidx => 0
        case sepidx                                         ' Use separator index to determine what gets copied to the output next
            0..2:                                           ' Index 0, 1, or 2 is a digit
                outstr.byte[outidx] := byte[instr][idx]
                idx--
                sepidx++
            3:                                              ' 3 means we're at the next thousands place - output a separator character
                outstr.byte[outidx] := sep_char
                sepidx := 0
        outidx--                                            ' Traverse one character
    outstr.byte[outlen] := 0                                ' When finished, terminate the array with a NUL(0) character, to make it a string
    longmove(@_strtemp, @outstr, 4)
    return @outstr

PUB Setup()

    ser.start(SER_BAUD)
    ser.clear()
    ser.printf("Serial terminal started - p2 @ %dMHz\n", clkfreq/1000000)

    vga.settimings(10, 33, 16, 89, 85, 640)
    vga.start(VGA_BASEPIN, @_framebuffer, @_palette, WIDTH, HEIGHT)
        ser.printf("VGA 8bpp driver started\n")
        vga.fontscale(1)
        vga.fontaddress(fnt.BaseAddr())
        vga.fontsize(6, 8)
        vga.clear()

    if sx1231.start(CS_PIN, SCK_PIN, MOSI_PIN, MISO_PIN, SCK_FREQ)
        ser.strln(string("SX1231 driver started"))
    else
        ser.strln(string("SX1231 driver failed to start - halting"))
        repeat

PUB GreyScalePalette() | i

    repeat i from 0 to 255
        _palette[i] := 0 | (i << 16) | (i << 8) | i

PUB FullSpecPalette() | i, r, g, b, c
' Set up palette
    r := g := b := c := 0
    repeat i from 0 to 255
        case i
            0..31:
                r += 4
                g := 0
                b += 4
            32..63:
                r -= 4
                g := 0
                b := b
            64..95:
                r := 0
                g += 4
                b := b
            96..127:
                r := 0
                g := g
                b -= 4
            128..159:
                r += 4
                g := g
                b := b
            160..191:
                r := r
                g -= 4
                b := 0
            192..254:
                r := r
                g += 4
                b += 4
            255:
                r := g := b := 255

        c := 0 | (r << 16) | (g << 8) | b
        _palette[i] := c
    _palette[0] := $00_00_00_00

{
    --------------------------------------------------------------------------------------------------------
    TERMS OF USE: MIT License

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
    associated documentation files (the "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
    following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial
    portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    --------------------------------------------------------------------------------------------------------
}

